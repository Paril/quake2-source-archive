
#include "../g_local.h"

// Generated by ModelEd

#define FRAME_grazeA1	0
#define FRAME_grazeA2	1
#define FRAME_grazeA3	2
#define FRAME_grazeA4	3
#define FRAME_grazeA5	4
#define FRAME_grazeA6	5
#define FRAME_grazeA7	6
#define FRAME_grazeA8	7
#define FRAME_grazeA9	8
#define FRAME_grazeA10	9
#define FRAME_grazeA11	10
#define FRAME_grazeA12	11
#define FRAME_grazeA13	12
#define FRAME_grazeA14	13
#define FRAME_grazeA15	14
#define FRAME_grazeA16	15
#define FRAME_grazeA17	16
#define FRAME_grazeA18	17
#define FRAME_grazeA19	18
#define FRAME_grazeA20	19
#define FRAME_grazeA21	20
#define FRAME_grazeA22	21
#define FRAME_grazeA23	22
#define FRAME_grazeA24	23
#define FRAME_grazeA25	24
#define FRAME_grazeA26	25
#define FRAME_grazeA27	26
#define FRAME_grazeA28	27
#define FRAME_grazeA29	28
#define FRAME_grazeA30	29
#define FRAME_grazeA31	30
#define FRAME_grazeA32	31
#define FRAME_grazeA33	32
#define FRAME_grazeA34	33
#define FRAME_grazeA35	34
#define FRAME_grazeA36	35
#define FRAME_grazeA37	36
#define FRAME_grazeA38	37
#define FRAME_grazeA39	38
#define FRAME_grazeA40	39
#define FRAME_grazeB1	40
#define FRAME_grazeB2	41
#define FRAME_grazeB3	42
#define FRAME_grazeB4	43
#define FRAME_grazeB5	44
#define FRAME_grazeB6	45
#define FRAME_grazeB7	46
#define FRAME_grazeB8	47
#define FRAME_grazeB9	48
#define FRAME_grazeB10	49
#define FRAME_grazeB11	50
#define FRAME_grazeB12	51
#define FRAME_grazeB13	52
#define FRAME_grazeB14	53
#define FRAME_grazeB15	54
#define FRAME_grazeB16	55
#define FRAME_grazeB17	56
#define FRAME_grazeB18	57
#define FRAME_grazeB19	58
#define FRAME_grazeB20	59
#define FRAME_grazeB21	60
#define FRAME_grazeB22	61
#define FRAME_grazeB23	62
#define FRAME_grazeB24	63
#define FRAME_grazeB25	64
#define FRAME_grazeB26	65
#define FRAME_grazeB27	66
#define FRAME_grazeB28	67
#define FRAME_grazeB29	68
#define FRAME_grazeB30	69
#define FRAME_grazeB31	70
#define FRAME_grazeB32	71
#define FRAME_grazeB33	72
#define FRAME_grazeB34	73
#define FRAME_grazeB35	74
#define FRAME_grazeB36	75
#define FRAME_grazeB37	76
#define FRAME_grazeB38	77
#define FRAME_grazeB39	78
#define FRAME_grazeB40	79
#define FRAME_gstepA10	80
#define FRAME_gstepA11	81
#define FRAME_gstepA12	82
#define FRAME_gstepA13	83
#define FRAME_gstepA14	84
#define FRAME_gstepA15	85
#define FRAME_gstepA16	86
#define FRAME_gstepA17	87
#define FRAME_gstepA18	88
#define FRAME_gstepA19	89
#define FRAME_gstepA20	90
#define FRAME_gstepA21	91
#define FRAME_gstepA22	92
#define FRAME_gstepA23	93
#define FRAME_gstepA24	94
#define FRAME_gstepA25	95
#define FRAME_gstepA26	96
#define FRAME_gstepA27	97
#define FRAME_gstepA28	98
#define FRAME_gstepA29	99
#define FRAME_gstepA30	100
#define FRAME_gstepB10	101
#define FRAME_gstepB11	102
#define FRAME_gstepB12	103
#define FRAME_gstepB13	104
#define FRAME_gstepB14	105
#define FRAME_gstepB15	106
#define FRAME_gstepB16	107
#define FRAME_gstepB17	108
#define FRAME_gstepB18	109
#define FRAME_gstepB19	110
#define FRAME_gstepB20	111
#define FRAME_gstepB21	112
#define FRAME_gstepB22	113
#define FRAME_gstepB23	114
#define FRAME_gstepB24	115
#define FRAME_gstepB25	116
#define FRAME_gstepB26	117
#define FRAME_gstepB27	118
#define FRAME_gstepB28	119
#define FRAME_gstepB29	120
#define FRAME_gstepB30	121
#define FRAME_lookup01	122
#define FRAME_lookup02	123
#define FRAME_lookup03	124
#define FRAME_lookup04	125
#define FRAME_lookup05	126
#define FRAME_lookup06	127
#define FRAME_lookup07	128
#define FRAME_lookup08	129
#define FRAME_lookup09	130
#define FRAME_lookup10	131
#define FRAME_lookup11	132
#define FRAME_lookup12	133
#define FRAME_look1	134
#define FRAME_look2	135
#define FRAME_look3	136
#define FRAME_look4	137
#define FRAME_look5	138
#define FRAME_look6	139
#define FRAME_look7	140
#define FRAME_look8	141
#define FRAME_look9	142
#define FRAME_look10	143
#define FRAME_look11	144
#define FRAME_look12	145
#define FRAME_look13	146
#define FRAME_look14	147
#define FRAME_look15	148
#define FRAME_look16	149
#define FRAME_look17	150
#define FRAME_look18	151
#define FRAME_look19	152
#define FRAME_look20	153
#define FRAME_look21	154
#define FRAME_look22	155
#define FRAME_look23	156
#define FRAME_look24	157
#define FRAME_look25	158
#define FRAME_look26	159
#define FRAME_look27	160
#define FRAME_look28	161
#define FRAME_look29	162
#define FRAME_look30	163
#define FRAME_look31	164
#define FRAME_look32	165
#define FRAME_look33	166
#define FRAME_look34	167
#define FRAME_look35	168
#define FRAME_look36	169
#define FRAME_look37	170
#define FRAME_look38	171
#define FRAME_look39	172
#define FRAME_look40	173
#define FRAME_look41	174
#define FRAME_look42	175
#define FRAME_look43	176
#define FRAME_look44	177
#define FRAME_look45	178
#define FRAME_look46	179
#define FRAME_look47	180
#define FRAME_look48	181
#define FRAME_look49	182
#define FRAME_look50	183
#define FRAME_look51	184
#define FRAME_look52	185
#define FRAME_look53	186
#define FRAME_look54	187
#define FRAME_look55	188
#define FRAME_look56	189
#define FRAME_look57	190
#define FRAME_look58	191
#define FRAME_look59	192
#define FRAME_look60	193
#define FRAME_pain1	194
#define FRAME_pain2	195
#define FRAME_pain3	196
#define FRAME_pain4	197
#define FRAME_pain5	198
#define FRAME_pain6	199
#define FRAME_pain7	200
#define FRAME_pain8	201
#define FRAME_tranA1	202
#define FRAME_tranA2	203
#define FRAME_tranA3	204
#define FRAME_tranA4	205
#define FRAME_tranA5	206
#define FRAME_tranA6	207
#define FRAME_tranA7	208
#define FRAME_tranA8	209
#define FRAME_tranA9	210
#define FRAME_tranA10	211
#define FRAME_tranB1	212
#define FRAME_tranB2	213
#define FRAME_tranB3	214
#define FRAME_tranB4	215
#define FRAME_tranB5	216
#define FRAME_tranB6	217
#define FRAME_tranB7	218
#define FRAME_tranB8	219
#define FRAME_tranB9	220
#define FRAME_tranB10	221
#define FRAME_tranB11	222
#define FRAME_tranB12	223
#define FRAME_trot1	224
#define FRAME_trot2	225
#define FRAME_trot3	226
#define FRAME_trot4	227
#define FRAME_trot5	228
#define FRAME_trot6	229
#define FRAME_trot7	230
#define FRAME_trot8	231
#define FRAME_trot9	232
#define FRAME_trot10	233
#define FRAME_wait1	234
#define FRAME_wait2	235
#define FRAME_wait3	236
#define FRAME_wait4	237
#define FRAME_wait5	238
#define FRAME_wait6	239
#define FRAME_wait7	240
#define FRAME_wait8	241
#define FRAME_wait9	242
#define FRAME_wait10	243
#define FRAME_wait11	244
#define FRAME_wait12	245
#define FRAME_wait13	246
#define FRAME_wait14	247
#define FRAME_wait15	248
#define FRAME_wait16	249

#define MODEL_SCALE	1.000000.


void sheep_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
	vec3_t	v;

	if ((!other->groundentity) || (other->groundentity == self))
		return;

	VectorSubtract (self->s.origin, other->s.origin, v);
        self->s.angles[YAW] = vectoyaw(v);
        self->count = 2;
        self->s.frame = FRAME_trot1;
}

void sheep_think (edict_t *self)
{
        // move sheep if trotting
        if (self->count == 2)
                M_walkmove (self, self->s.angles[YAW], 6);

        if (!self->count && (self->s.frame >= FRAME_grazeA40))
                self->s.frame = FRAME_grazeA1;
        if ((self->count == 1) && (self->s.frame >= FRAME_grazeB40))
                self->s.frame = FRAME_grazeB1;
        if ((self->count == 2) && (self->s.frame >= FRAME_trot8))
                self->count = (int)random();

        self->s.frame++;

        // occasionally change the grazing animation or wander off
        if ((self->count != 2) && (random() < 0.01))
        {
                if (random() < 0.5)
                {
                        self->s.angles[YAW] += random()*180-90;
                        self->count = 2;
                        self->s.frame = FRAME_trot1;
                }
                else if (!self->count)
                {
                        self->count = 1;
                        self->s.frame = FRAME_grazeB1;
                }
                else
                {
                        self->count = 0;
                        self->s.frame = FRAME_grazeA1;
                }
        }

        // occaisionally make a noise
        if (random() < 0.02)
        {
                int     r;

                r = random()*2;
                switch (r)
                {
                case 0:
                        gi.sound(self, CHAN_AUTO, SoundIndex("misc/sheep1.wav"), 1, ATTN_NORM, 0);
                        break;
                case 1:
                        gi.sound(self, CHAN_AUTO, SoundIndex("misc/sheep2.wav"), 1, ATTN_NORM, 0);
                        break;
                case 3:
                        gi.sound(self, CHAN_AUTO, SoundIndex("misc/sheep3.wav"), 1, ATTN_NORM, 0);
                        break;
                }
        }

        self->nextthink = level.time + FRAMETIME;
}

void sheep_pain (edict_t *self, edict_t *other, float kick, int damage)
{
	if (level.time < self->pain_debounce_time)
		return;

        self->pain_debounce_time = level.time + 3;
        gi.sound (self, CHAN_AUTO, SoundIndex ("misc/sheepdie.wav"), 1, ATTN_NORM, 0);
}

void sheep_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
        int     n;

        gi.sound (self, CHAN_VOICE, SoundIndex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
        for (n= 0; n < 2; n++)
                ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
        for (n= 0; n < 4; n++)
                ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);       
        self->deadflag = DEAD_DEAD;
        self->nextthink = 0;
        self->s.modelindex = 0;
        self->s.effects = 0;
        gi.linkentity(self);
        G_FreeEdict(self);
}

void sheep_create (edict_t *self)
{
        self->movetype = MOVETYPE_STEP;
        self->solid = SOLID_BBOX;
        self->s.modelindex = ModelIndex("models/misc/sheep/tris.md2");
        VectorSet(self->maxs, 20, 10, 30);
        VectorSet(self->mins, -20, -10, 0);

        self->health = 100;
        self->gib_health = -1;
        self->mass = 200;

        self->pain = sheep_pain;
        self->die = sheep_die;
        self->touch = sheep_touch;
	self->takedamage = DAMAGE_YES;
        self->svflags |= SVF_MONSTER;
        self->classname = "sheep";

        gi.linkentity (self);

        self->count = (int)random();
        self->think = sheep_think;
        self->nextthink = level.time + FRAMETIME;

        M_droptofloor(self);
}


void barrel_explode (edict_t *self);

/* Functions added by DWH to get around compiler warnings/possible game errors */
void barrel_die_explode (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
	self->takedamage = DAMAGE_NO;
	self->nextthink = level.time + FRAMETIME;
	self->think = barrel_explode;
	self->activator = attacker;
}
void barrel_touch_explode (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
	self->takedamage = DAMAGE_NO;
	self->nextthink = level.time + FRAMETIME;
	self->think = barrel_explode;
	self->activator = other;
}

// remove_target: remove a monster from the level completely
void remove_target (edict_t *ent, edict_t *targ, int mod)
{
        targ->s.modelindex = 0;
        targ->s.effects = 0;

        if (targ->client)
        {
                targ->client->pigged = true;
                // have to use NO_PROTECTION _and_ NO_ARMOR in here cos NO_PROTECTION doesn't work right
                T_Damage (targ, ent, ent, ent->client->v_angle, targ->s.origin, vec3_origin, (targ->health+5), 0, DAMAGE_NO_ARMOR|DAMAGE_NO_PROTECTION, mod);
        }
        else
        {
			meansOfDeath = mod;
			MonsterObituary (targ, ent, ent);
                monster_death_use (targ);
                targ->nextthink = 0;
                gi.linkentity(targ);

                // 'officially' remove monster from level (unless a sheep)
                if (Q_stricmp(targ->classname, "misc_sheep") != 0)
                {
                        level.killed_monsters++;
                        if (coop->value)
                                ent->client->resp.score++;
                }

                G_FreeEdict(targ);
        }
}

// checksplat: checks to see if an inverted ent has hit the ceiling
void pig_checksplat (edict_t *ent)
{
        vec3_t  v1, v2, v3;

        VectorCopy(ent->s.origin, v1);
        v1[2] += ent->maxs[2] + 2;

        VectorCopy(v1, v2);
        VectorCopy(v1, v3);

        v2[0] += ent->maxs[0];
        v2[1] += ent->maxs[1];

        v3[0] += ent->mins[0];
        v3[1] += ent->mins[1];

        if ((gi.pointcontents(v1) & MASK_ALL)
                || (gi.pointcontents(v2) & MASK_ALL)
                || (gi.pointcontents(v3) & MASK_ALL))
        {
                ent->gravity *= -1;
                ent->s.angles[ROLL] -= 180;
                ent->s.effects = 0;
                ent->s.renderfx = 0;
                T_Damage (ent, ent, ent, ent->s.angles, ent->s.origin, vec3_origin, 10000, 0, DAMAGE_NO_PROTECTION, MOD_PIG_GRAVITY);
                if (ent->client)
                {
                        ent->gravity = 1;
                        ent->velocity[2] = 0;
                        ent->s.origin[2] -= 48; // pull them out of the ceiling
                        if (ent->client->ps.pmove.pm_flags & PMF_NO_PREDICTION)
                                ent->client->ps.pmove.pm_flags &= ~PMF_NO_PREDICTION;
                }
        }
}


void pig_gib (edict_t *ent, edict_t *targ)
{
        // green blast
	gi.WriteByte (svc_temp_entity);
	gi.WriteByte (TE_BFG_BIGEXPLOSION);
        gi.WritePosition (targ->s.origin);
        gi.multicast (targ->s.origin, MULTICAST_PVS);

        // gib em
        T_Damage (targ, ent, ent, ent->client->v_angle, targ->s.origin, vec3_origin, 10000, 0, DAMAGE_NO_PROTECTION, MOD_PIG_GIB);
}

void remove_groundshake_think (edict_t *self)
{
        edict_t *e;
        int     i;

	for (i=1, e=g_edicts+i; i < globals.num_edicts; i++,e++)
	{
		if (!e->inuse)
			continue;
		if (!e->groundentity)
			continue;

		e->groundentity = NULL;
		e->velocity[0] += crandom()* 150;
		e->velocity[1] += crandom()* 150;
                if (e->client)
                        e->velocity[2] = 300 * (100.0 / e->mass);
                else if (e->monsterinfo.stand)
                        e->velocity[2] = 50 * (100.0 / e->mass);                        
	}

        if (level.time < self->timestamp)
                self->nextthink = level.time + FRAMETIME;
}        

void pig_remove (edict_t *ent, edict_t *targ)
{
        edict_t *s;
                        
        // blue shockwave
	gi.WriteByte (svc_temp_entity);
	gi.WriteByte (TE_NUKEBLAST);
        gi.WritePosition (targ->s.origin);
        gi.multicast (targ->s.origin, MULTICAST_ALL);

        // the sound
        gi.sound(ent, CHAN_AUTO, SoundIndex("misc/bigtele.wav"), 1, ATTN_NONE, 0);

        // bright flash
        ent->client->bonus_alpha = 0.5;

        // start the ground shaking
        s = G_Spawn();
        s->timestamp = level.time + 3;
        s->think = remove_groundshake_think;
        remove_groundshake_think(s);

        remove_target (ent, targ, MOD_PIG_REMOVE);
}

// Paril: Function I made to
// get a random item from the itemlist.
gitem_t *GetRandomItem ()
{
	gitem_t *test;
	int was_health = 0;

retry:

	test = &itemlist[rand()%game.num_items];

	if (!test->flags & IT_WEAPON || !test->flags & IT_AMMO || !test->flags & IT_POWERUP || !test->flags & IT_HEALTH)
		goto retry;
	if (!test->world_model)
		goto retry;
	//if (!test->classname)
	//	goto retry;

	if (Q_stricmp(test->pickup_name, "Health") == 0)
	{
		was_health = 1;
	}

	// Whoops?
	if (!test && !was_health)
	{
		gi.dprintf ("GetRandomItem returned a null item!\n");
		test = &itemlist[1];
	}
	else if (was_health)
		return NULL;

	return test;
}

void SP_item_health_large (edict_t *self);
void SP_item_health_mega (edict_t *self);
void SP_item_health_small (edict_t *self);
void SP_item_health (edict_t *self);
void SP_misc_explobox (edict_t *self);
void sheep_create (edict_t *self);
void pig_transform (edict_t *ent, edict_t *targ)
{
        edict_t *new;
        int     r;
		gitem_t *item;

        new = G_Spawn();
        VectorCopy (targ->s.origin, new->s.origin);
        new->s.origin[2] += 32; // make sure new thingy is well off ground

        gi.WriteByte (svc_muzzleflash);
        gi.WriteShort (targ-g_edicts);
        gi.WriteByte (MZ_LOGIN);
        gi.multicast (targ->s.origin, MULTICAST_PVS);

		item = GetRandomItem();

		if (item == NULL) // Health
		{
			if (random() < 0.3)
				SP_item_health_large (new);
			else if (random() < 0.6)
				SP_item_health (new);
			else if (random() < 0.9)
				SP_item_health_small (new);
			else
				SP_item_health_mega (new);

			return;
		}

        // every now and then make em into a sheep
        if (random() < 0.4)
        {
                sheep_create(new);
				remove_target (ent, targ, MOD_PIG_TRANSFORM);
                return;
        }
        r = random()*4;

		new->item = item;
		new->spawnflags = DROPPED_ITEM;

        switch(r)
        {
        /*case 0:
        default:
                SP_item_health_large(new);
                break;
        case 1:
                SpawnItem(new, FindItem("Combat Armor"));
                break;
        case 2:
                SpawnItem(new, FindItem("Quad Damage"));
                break;*/
        /*case 0:
                SP_misc_explobox(new);
                break;*/
		default:
//			gi.dprintf ("%s %s\n", item->pickup_name, item->classname);
			//SpawnItem (new, item);
			Drop_Item (targ, item);
			break;
        }
        remove_target (ent, targ, MOD_PIG_TRANSFORM);
}

void pig_drop (edict_t *ent, edict_t *targ)
{
        edict_t *thingy;
        trace_t tr;
        vec3_t  start, up, dir, end, mins, maxs;

        thingy = G_Spawn();

        VectorSet (thingy->mins, -16, -16, 0);
        VectorSet (thingy->maxs, 1, 16, 40);

        VectorSet(up, -90, 0, 0);
        AngleVectors(up, dir, NULL, NULL);
        VectorCopy(targ->s.origin, start);
        start[2] += targ->maxs[2] + 2;
        VectorMA(start, 8192, dir, end);
        tr = gi.trace(targ->s.origin, mins, maxs, end, targ, MASK_ALL);
        VectorCopy (tr.endpos, thingy->s.origin);
        thingy->s.origin[2] -= 42; // lower barrel so it isn't in the ceiling

        thingy->solid = SOLID_BBOX;
        thingy->movetype = MOVETYPE_STEP;

        thingy->model = "models/objects/barrels/tris.md2";
        thingy->s.modelindex = ModelIndex (thingy->model);
        VectorSet (thingy->mins, -16, -16, 0);
        VectorSet (thingy->maxs, 16, 16, 40);

        thingy->mass = 400;
        thingy->health = 10;
        thingy->dmg = 80;

        thingy->activator = ent;
/*      thingy->die = barrel_explode;
        thingy->touch = barrel_explode;
		Change by DWH to use proper prototypes */
		thingy->die = barrel_die_explode;
		thingy->touch = barrel_touch_explode;

        thingy->takedamage = DAMAGE_NO;

        VectorSet(thingy->velocity, 0, 0, -50);

        gi.linkentity (thingy);
}

void pig_swap (edict_t *ent, edict_t *targ)
{
        vec3_t  temp;

        VectorCopy(ent->s.origin, temp);
        VectorCopy(targ->s.origin, ent->s.origin);
        VectorCopy(temp, targ->s.origin);

        // make sure neither ents are in ground
        ent->s.origin[2] += ent->mins[2] - targ->mins[2] + 2;
        targ->s.origin[2] += targ->mins[2] - ent->mins[2] + 2;
        M_droptofloor(targ);

        // bright flash
        ent->client->bonus_alpha = 0.5;
        if (targ->client)
                targ->client->bonus_alpha = 0.5;

        // send movement effect to client
        gi.WriteByte (svc_muzzleflash);
        gi.WriteShort (ent-g_edicts);
        gi.WriteByte (MZ_LOGOUT);
        gi.multicast (ent->s.origin, MULTICAST_PVS);
        if (targ->client)
        {
                gi.WriteByte (svc_muzzleflash);
                gi.WriteShort (targ-g_edicts);
                gi.WriteByte (MZ_LOGOUT);
                gi.multicast (targ->s.origin, MULTICAST_PVS);
        }

        // hold in place briefly
        ent->client->ps.pmove.pm_flags = PMF_TIME_TELEPORT;
        ent->client->ps.pmove.pm_time = 14;
        if (targ->client)
        {
                targ->client->ps.pmove.pm_flags = PMF_TIME_TELEPORT;
                targ->client->ps.pmove.pm_time = 14;
        }
}


void pig_gravity (edict_t *ent, edict_t *targ)
{
        int     d;

        gi.dprintf("Inverting gravity...\n");

        if (targ->client)
        {
                targ->gravity = -1;
//                targ->s.origin[2] += 4; // get em off the floor
                targ->velocity[2] = 500;
        }
        else
        {
                targ->gravity *= -1;
                targ->velocity[2] = -5 * targ->gravity;
                targ->s.angles[ROLL] += 180;
        }

// flip their bounding box
        d = targ->maxs[2] - (targ->mins[2] * -1);
        targ->s.origin[2] += d + 2;
        targ->maxs[2] -= d;
        targ->mins[2] -= d;
}

void fire_pig (edict_t *ent, edict_t *targ)
{
        int     r;

        r = random()*10;

        switch(r)
        {
        //case 0:             
        default:
                pig_transform (ent, targ);
                break;
        case 1:
        case 2:
                pig_remove (ent, targ);
                break;
        case 3:
        case 4:
        case 5:
                pig_transform (ent, targ);
                break;
        case 6:
        case 7:
                pig_drop (ent, targ);
                break;
        case 8:
                pig_swap (ent, targ);
                break;
        case 9:
                pig_gravity (ent, targ);
                break;
        }
}


/*
======================================================================

PIG 2000 (Physical Improbability Generator)

======================================================================
*/

qboolean pig_gettarg (edict_t *ent)
{
        trace_t tr;
        vec3_t  start, forward, end;

        VectorCopy(ent->s.origin, start);
        start[2] += ent->viewheight;
        AngleVectors(ent->client->v_angle, forward, NULL, NULL);
        VectorMA(ent->s.origin, 8192, forward, end);

        tr = gi.trace(ent->s.origin, NULL, NULL, end, ent, MASK_ALL);

        if (!tr.ent || (!(tr.ent->svflags & SVF_MONSTER) && !tr.ent->client))
        {
                if (ent->client->notarg_debounce_time < level.time)
                {
                        safe_cprintf(ent, PRINT_HIGH, "No target\n");
                        ent->client->notarg_debounce_time = level.time + 0.5;
                }
                return false;
        }

        ent->enemy = tr.ent;
        return true;
}

void fire_pig (edict_t *ent, edict_t *targ);

void weapon_pig_fire (edict_t *ent)
{     
	if (ent->client->ps.gunframe == 9)
	{
		// send muzzle flash
		gi.WriteByte (svc_muzzleflash);
		gi.WriteShort (ent-g_edicts);
		gi.WriteByte (MZ_BFG | is_silenced);
		gi.multicast (ent->s.origin, MULTICAST_PVS);

		ent->client->ps.gunframe++;

                PlayerNoise(ent, ent->s.origin, PNOISE_WEAPON);
		return;
	}

        // make sure target still exists
        if (!ent->enemy || (!(ent->enemy->svflags & SVF_MONSTER) && !ent->enemy->client))
        {
                safe_cprintf(ent, PRINT_HIGH, "No target\n");
                ent->client->ps.gunframe++;
                return;
        }

        PlayerNoise(ent, ent->s.origin, PNOISE_WEAPON);
        fire_pig (ent, ent->enemy);
        ent->enemy = NULL;

        ent->client->ps.gunframe++;

	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
                ent->client->pers.inventory[ent->client->ammo_index] -= 25+random()*25;
}

void Weapon_PIG (edict_t *ent)
{
	static int	pause_frames[]	= {39, 45, 50, 55, 0};
        static int      fire_frames[]   = {9, 17, 0};

        Weapon_Generic (ent, 8, 32, 55, 58, pause_frames, fire_frames, weapon_pig_fire);
}
